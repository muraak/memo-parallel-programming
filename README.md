
# 並列プログラミングに関するメモ

## バリア

プロセッサは、プログラムに記述された命令の実行順（命令オーダ）や、メモリアクセス順序（メモリオーダ）を保証するとは限らない。性能を向上させるために命令やメモリアクセストランザクションの入れ替えを行う。命令オーダおよびメモリオーダの入れ替えを行うか否かはプロセッサの仕様に依存する。メモリやデバイス、CPU制御レジスタを共有するマルチプロセッサシステム（場合によっては単一プロセッサシステム）では、各コアで前記命令・メモリのリオーダが発生することで、共有資源を正しく観測できなかったり、デバイスを正しく制御できない場合がある。
バリアとは、そのようなプロセッサシステムにおける、命令およびメモリアクセスの順序を制御する命令の集合を指す。

>NOTE: ARMv8 AArch64では、メモリオーダは相互接続するDDRなどの[デバイス依存](https://community.arm.com/support-forums/f/architectures-and-processors-forum/6354/barriers-in-in-order-cores-like-cortex-a53-a7)（ほとんどの場合リオーダすると考えた方が安全）であり、命令オーダはCA53/CA57などはインオーダ、CA72等はアウトオブオーダである（[参考](https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_processors)）

### バリアの種類（ARMv8）

#### データメモリバリア(DMB)

##### DMB SY

バリア以前のメモリアクセス命令は、バリア命令以降のすべてのメモリアクセス命令が実行される前に完了する。
メモリアクセス命令以外の命令には効果をもたない。

##### DMB ST

バリア以前のすべてのストア命令は、バリア命令以降のすべてのストア命令が実行される前に完了する。
メモリアクセス命令以外の命令には効果をもたない。

##### DMB LD

バリア以前のすべてのロード命令は、バリア命令以降のすべてのメモリアクセス命令が実行される前に完了する。
メモリアクセス命令以外の命令には効果をもたない。

#### データ同期バリア(DSB)
##### DSB SY

バリア以前のメモリアクセス命令は、バリアの完了時に完了する。
バリア命令以降に配置されたすべての命令は、バリアが完了するまで実行されない。

##### DSB ST

バリア以前のすべてのストア命令は、バリアの完了時に完了する。
バリア命令以降に配置されたすべての命令は、バリアが完了するまで実行されない。

##### DSB LD

バリア以前のすべてのロード命令は、バリアの完了時に完了する。
バリア命令以降に配置されたすべての命令は、バリアが完了するまで実行されない。

#### DMB/DSBのその他のオプション

なお、以下のようにオプションを変更すると、上記の3つオプションに加えて、バリアの作用を及ぼすメモリアクセス先（共有ドメイン）を限定することができる。

- `SY`(全システム) -> `OSH`(Outer Sharableドメイン) -> `ISH`(Inner Sharableドメイン) -> `NSH`(Non-sharableドメイン)
- `ST`(全システム) -> `OSHST`(Outer Sharableドメイン) -> `ISHST`(Inner Sharableドメイン) -> `NSHST`(Non-sharableドメイン)
- `LD`(全システム) -> `OSHLD`(Outer Sharableドメイン) -> `ISHLD`(Inner Sharableドメイン) -> `NSHLD`(Non-sharableドメイン)

各共有ドメインの定義イメージを以下に引用する（[参考元](https://developer.arm.com/documentation/100941/0100/Memory-attributes)）：

![img](https://documentation-service.arm.com/static/5efa1dbedbdee951c1ccded0?token=)


#### 命令バリア(ISB)

バリアの挿入位置以前の命令による、システム制御レジスタへのアクセスおよびアクセスによる副作用が全て完了し、挿入位置以降の命令から観測できることを保証する。
さらに、バリアの挿入位置以降の命令によるシステム制御レジスタへのアクセスおよびアクセスによる副作用は、バリアの挿入位置以前には発生しないことを保証する。

例）

以下の例では、システム制御レジスタCPACR_EL1にリードモディファイライトすることで、FPU（浮動小数点演算ユニットと）とSIMD（ベクトル処理）を有効化したあとでバリアを実行している。したがって、以降の命令C、命令Dは浮動小数点演算ユニット・ベクトル処理が有効化された状態で実行されることが保証される。また、ISB実行時にパイプラインは粛清されるので、命令C、命令Dはバリアの実行後、再度メモリ（またはキャッシュ）からフェッチされる。

```
MRS X1, CPACR_EL1
ORR X1, X1, #(0x3 << 20) // FPU と SIMD を有効化
MSR CPACR_EL1, X1
ISB // 命令バリア
命令C
命令D
```

#### 参考

1. https://developer.arm.com/documentation/dui0489/c
1. https://developer.arm.com/documentation/ddi0596/2021-12/Base-Instructions/DSB--Data-Synchronization-Barrier-?lang=en
1. https://github.com/Broadcom/arm64-linux/blob/master/Documentation/memory-barriers.txt

### C/C++でのバリアの使い方

C/C++プログラムでは、バリアはインラインアセンブラで記述するか、ほとんどの場合プラットフォームの提供するプロセッサアーキテクチャ非依存のマクロで、バリアを利用する。

<!-- ### glibc
### linuxカーネル
### Toppers -->

## ライブラリ依存の機能

未

## OS依存の機能

未
