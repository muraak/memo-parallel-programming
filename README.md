
# 並列プログラミングに関するメモ

## バリア

プロセッサは、プログラムに記述された命令の実行順（命令オーダ）や、メモリアクセス順序（メモリオーダ）を保証するとは限らない。性能を向上させるために命令やメモリアクセストランザクションの入れ替えを行う。命令オーダおよびメモリオーダの入れ替えを行うか否かはプロセッサの仕様に依存する。メモリやデバイス、CPU制御レジスタを共有するマルチプロセッサシステム（場合によっては単一プロセッサシステム）では、各コアで前記命令・メモリのリオーダが発生することで、共有資源を正しく観測できなかったり、デバイスを正しく制御できない場合がある。
バリアとは、そのようなプロセッサシステムにおける、命令およびメモリアクセスの順序を制御する命令の集合を指す。

>NOTE: ARMv8 AArch64では、メモリオーダは相互接続するDDRなどの[デバイス依存](https://community.arm.com/support-forums/f/architectures-and-processors-forum/6354/barriers-in-in-order-cores-like-cortex-a53-a7)（ほとんどの場合リオーダすると考えた方が安全）であり、命令オーダはCA53/CA57などはインオーダ、CA72等はアウトオブオーダである（[参考](https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_processors)）

### バリアの種類（ARMv8）

#### データメモリバリア

#### データ同期バリア

#### 命令バリア

バリアの挿入位置以前の命令による、システム制御レジスタへのアクセスおよびアクセスによる副作用が全て完了し、挿入位置以降の命令から観測できることを保証する。
さらに、バリアの挿入位置以降の命令によるシステム制御レジスタへのアクセスおよびアクセスによる副作用は、バリアの挿入位置以前には発生しないことを保証する。

例）

以下の例では、システム制御レジスタCPACR_EL1にリードモディファイライトすることで、FPU（浮動小数点演算ユニットと）とSIMD（ベクトル処理）を有効化したあとでバリアを実行している。したがって、以降の命令C、命令Dは浮動小数点演算ユニット・ベクトル処理が有効化された状態で実行されることが保証される。また、ISB実行時にパイプラインは粛清されるので、命令C、命令Dはバリアの実行後、再度メモリ（またはキャッシュ）からフェッチされる。

```
MRS X1, CPACR_EL1
ORR X1, X1, #(0x3 << 20) // FPU と SIMD を有効化
MSR CPACR_EL1, X1
ISB // 命令バリア
命令C
命令D
```

#### 参考

1. https://github.com/Broadcom/arm64-linux/blob/master/Documentation/memory-barriers.txt

### C/C++でのバリアの使い方

C/C++プログラムでは、バリアはインラインアセンブラで記述するか、ほとんどの場合プラットフォームの提供するプロセッサアーキテクチャ非依存のマクロで、バリアを利用する。

<!-- ### glibc
### linuxカーネル
### Toppers -->

## ライブラリ依存の機能

未

## OS依存の機能

未
